JVM：
    1. 运行时的区域划分：
        线程私有
            程序计数器：记录当前线程跑到哪一行代码了
            虚拟机栈：   描述java方法的内存模型，native方法
            本机方法栈：
             HotspotJVM种本地方法栈与虚拟机栈合二为一
        线程共享
            堆：所有对象实例以及数组对象
            方法区：已加载的类信息，一个类的类型，有什么属性，方法，都在方法区记录
            运行时常量池：方法区的一部分，存放的是字面量与符号引用(字面量：直接写出来的值比如 int a = 10)
                            符号引用：通过包名，类名先找到类，然后new对象。不同包的不同类就是不同的符号引用
    2. GC相关：(如何判断对象是否存活->对象的自我拯救(finalize方法)->如何进行垃圾回收)
         引用计数法：有一个地方引用对象，+1，该引用为空时，-1，为0时，说明不在存活(无法解决循环引用问题，我中有你，你中有我)
                    导致无用对象无法判断存活进而无法回收从而造成内存泄漏。
         可达性分析法：
            哪些对象可以作为GC Roots ：
                栈中的引用对象
                类中的静态变量，常量引用的对象

         ->对象的自我拯救  finalize    JDK1.9 @Deprecated
            -若对象的类覆写了 finalize()
                -该对象的finalize()未被JVM调用过，JVM会调用此对象的finalize()
                -该对象的finalize()被JVM调用过，此对象被标记为不在存活，可以进行GC
            -没有覆写finalize(),此时对象直接标记为不在存活，可以进行GC
         final  finally  finalize

         ->垃圾回收算法：
            java采用分代回收算法，对象默认在新生代中产生。在堆中，其中新生代采用复制算法(新生代的存活率低 <= 2％)，
            老年代采用标记-整理算法  新生代的GC比老年代的快10倍，而且发生频率高
                复制算法：把新生代分为 Eden Survivor-From Survivor-To
                    step1. 当Eden区第一次快慢时，将Eden区所有有的存活对象复制到From区，而后一次性清理掉Eden
                    step2. 当Eden第二次快满时，将Eden区与from区中存活的对象复制到To区，一次性清理掉Eden和from
                    step n....
                            若干对象若在from和to来回复制15次以上，将此对象移动至老年代
            -Xss(设置栈的大小)128k
            -Xms(设置堆的最小值)10m
            -Xmx(设置堆的最大值)
            -Xmn(设置新生代的内存大小)
            为何老年代不采用复制算法？
                因为老年代存活率很高，若采用，复制开销远高于新生代。
         五星面试题：
            关于jdk1.2之后 引用的扩充
                -强引用 Person per = new Person();原先程序中普遍存在的，类似于直接new的，称为强引用，
                    即便对象被任意一个强引用指向，抛出了OOM(out of memory)都无法被回收
                -软引用 描述有用但不必须的对象，使用softReference类描述软引用
                    若对象只被软引用指向，当前内存够用不回收，当即将抛出OOM时，一次性回收软引用
                    指向的对象
                -弱引用 仅被弱引用指向的对象，无论Mem是否够用，当GC开始时，都会被回收
                -虚引用 PhantomReference 幽灵引用，完全不对对象的生存周期产生任何影响，也无法通过
                        虚引用取得一个对象的实例，当虚引用指向的对象被GC时，JVM会发回一个回收通知
                        主要就干这个事
    3. JDK内置工具的使用
        JPS     看id
        jmap    看堆
        jstack  看栈
    4. JMM
        volatile(选看)
            -可见性
            volatile boolean flag = true;----------------在这句话相当一堵墙 把上面和下面的代码隔开
            -禁止指令重排(Double-Check-Singleton双重加锁单例模式)
                1.volatile代码既不会提前也不会滞后
                2.volatile代码前的所有代码一定全部执行完毕，volatile之后的所有代码一定还未开始

                volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。
                多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞
                volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。
                volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。